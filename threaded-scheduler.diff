diff --git a/drivers/run_tests.cpp b/drivers/run_tests.cpp
index 00b3cab..c38ea99 100644
--- a/drivers/run_tests.cpp
+++ b/drivers/run_tests.cpp
@@ -74,7 +74,7 @@ typedef std::map< fs::path, int64_t > path_to_id_map;
 
 
 /// Map of in-flight PIDs to their corresponding test case IDs.
-typedef std::map< int, int64_t > pid_to_id_map;
+typedef std::map< scheduler::exec_handle, int64_t > pid_to_id_map;
 
 
 /// Pair of PID to a test case ID.
@@ -311,10 +311,10 @@ drivers::run_tests::drive(const fs::path& kyuafile_path,
             scheduler::result_handle_ptr result_handle = handle.wait_any();
 
             const pid_to_id_map::iterator iter = in_flight.find(
-                result_handle->original_pid());
+                result_handle->original_exec_handle());
             INV_MSG(iter != in_flight.end(),
                     F("Lost track of in-flight PID %s; tracking %s") %
-                    result_handle->original_pid() % format_pids(in_flight));
+                    result_handle->original_exec_handle() % format_pids(in_flight));
             const int64_t test_case_id = (*iter).second;
             in_flight.erase(iter);
 
diff --git a/engine/scheduler.cpp b/engine/scheduler.cpp
index 2270430..fb37441 100644
--- a/engine/scheduler.cpp
+++ b/engine/scheduler.cpp
@@ -32,10 +32,12 @@ extern "C" {
 #include <unistd.h>
 }
 
+#include <condition_variable>
 #include <cstdio>
 #include <cstdlib>
 #include <fstream>
 #include <memory>
+#include <mutex>
 #include <stdexcept>
 
 #include "engine/config.hpp"
@@ -80,6 +82,19 @@ using utils::none;
 using utils::optional;
 
 
+// 1. Start test thread
+// 2. Add thread to active threads
+// 3. Wait for semaphore
+// 4. Thread adds result to results set, signals semaphore
+// 5. Acquire semaphore
+// 6. Remove thread from active threads, return result
+// 7. Consumer uses result, calls cleanup
+// 8. Cleanup removes self from results set
+//
+// If signal after 2, kill active threads and run cleanups from scratch
+// If signal after 6, 
+
+
 /// Timeout for the test case cleanup operation.
 ///
 /// TODO(jmmv): This is here only for testing purposes.  Maybe we should expose
@@ -124,6 +139,27 @@ typedef std::map< std::string, std::shared_ptr< scheduler::interface > >
 static interfaces_map interfaces;
 
 
+struct test_id {
+    std::string test_program_name;
+    std::string test_case_name;
+
+    bool
+    operator<(const test_id& other) const
+    {
+        return (test_program_name < other.test_program_name)
+            || (test_program_name == other.test_program_name
+                && test_case_name < other.test_case_name);
+    }
+
+    bool
+    operator==(const test_id& other) const
+    {
+        return test_program_name == other.test_program_name
+            && test_case_name == other.test_case_name;
+    }
+};
+
+
 /// Scans the contents of a directory and appends the file listing to a file.
 ///
 /// \param dir_path The directory to scan.
@@ -158,125 +194,6 @@ append_files_listing(const fs::path& dir_path, const fs::path& output_file)
 }
 
 
-/// Maintenance data held while a test is being executed.
-///
-/// This data structure exists from the moment when a test is executed via
-/// scheduler::spawn_test() or scheduler::impl::spawn_cleanup() to when it is
-/// cleaned up with result_handle::cleanup().
-///
-/// This is a base data type intended to be extended for the test and cleanup
-/// cases so that each contains only the relevant data.
-struct exec_data : utils::noncopyable {
-    /// Test program data for this test case.
-    const model::test_program_ptr test_program;
-
-    /// Name of the test case.
-    const std::string test_case_name;
-
-    /// Constructor.
-    ///
-    /// \param test_program_ Test program data for this test case.
-    /// \param test_case_name_ Name of the test case.
-    exec_data(const model::test_program_ptr test_program_,
-              const std::string& test_case_name_) :
-        test_program(test_program_), test_case_name(test_case_name_)
-    {
-    }
-
-    /// Destructor.
-    virtual ~exec_data(void)
-    {
-    }
-};
-
-
-/// Maintenance data held while a test is being executed.
-struct test_exec_data : public exec_data {
-    /// Test program-specific execution interface.
-    const std::shared_ptr< scheduler::interface > interface;
-
-    /// User configuration passed to the execution of the test.  We need this
-    /// here to recover it later when chaining the execution of a cleanup
-    /// routine (if any).
-    const config::tree user_config;
-
-    /// Whether this test case still needs to have its cleanup routine executed.
-    ///
-    /// This is set externally when the cleanup routine is actually invoked to
-    /// denote that no further attempts shall be made at cleaning this up.
-    bool needs_cleanup;
-
-    /// The exit_handle for this test once it has completed.
-    ///
-    /// This is set externally when the test case has finished, as we need this
-    /// information to invoke the followup cleanup routine in the right context,
-    /// as indicated by needs_cleanup.
-    optional< executor::exit_handle > exit_handle;
-
-    /// Constructor.
-    ///
-    /// \param test_program_ Test program data for this test case.
-    /// \param test_case_name_ Name of the test case.
-    /// \param interface_ Test program-specific execution interface.
-    /// \param user_config_ User configuration passed to the test.
-    test_exec_data(const model::test_program_ptr test_program_,
-                   const std::string& test_case_name_,
-                   const std::shared_ptr< scheduler::interface > interface_,
-                   const config::tree& user_config_) :
-        exec_data(test_program_, test_case_name_),
-        interface(interface_), user_config(user_config_)
-    {
-        const model::test_case& test_case = test_program->find(test_case_name);
-        needs_cleanup = test_case.get_metadata().has_cleanup();
-    }
-};
-
-
-/// Maintenance data held while a test cleanup routine is being executed.
-///
-/// Instances of this object are related to a previous test_exec_data, as
-/// cleanup routines can only exist once the test has been run.
-struct cleanup_exec_data : public exec_data {
-    /// The exit handle of the test.  This is necessary so that we can return
-    /// the correct exit_handle to the user of the scheduler.
-    executor::exit_handle body_exit_handle;
-
-    /// The final result of the test's body.  This is necessary to compute the
-    /// right return value for a test with a cleanup routine: the body result is
-    /// respected if it is a "bad" result; else the result of the cleanup
-    /// routine is used if it has failed.
-    model::test_result body_result;
-
-    /// Constructor.
-    ///
-    /// \param test_program_ Test program data for this test case.
-    /// \param test_case_name_ Name of the test case.
-    /// \param body_exit_handle_ If not none, exit handle of the body
-    ///     corresponding to the cleanup routine represented by this exec_data.
-    /// \param body_result_ If not none, result of the body corresponding to the
-    ///     cleanup routine represented by this exec_data.
-    cleanup_exec_data(const model::test_program_ptr test_program_,
-                      const std::string& test_case_name_,
-                      const executor::exit_handle& body_exit_handle_,
-                      const model::test_result& body_result_) :
-        exec_data(test_program_, test_case_name_),
-        body_exit_handle(body_exit_handle_), body_result(body_result_)
-    {
-    }
-};
-
-
-/// Shared pointer to exec_data.
-///
-/// We require this because we want exec_data to not be copyable, and thus we
-/// cannot just store it in the map without move constructors.
-typedef std::shared_ptr< exec_data > exec_data_ptr;
-
-
-/// Mapping of active PIDs to their maintenance data.
-typedef std::map< int, exec_data_ptr > exec_data_map;
-
-
 /// Enforces a test program to hold an absolute path.
 ///
 /// TODO(jmmv): This function (which is a pretty ugly hack) exists because we
@@ -594,12 +511,7 @@ struct engine::scheduler::result_handle::impl : utils::noncopyable {
     /// Generic executor exit handle for this result handle.
     executor::exit_handle generic;
 
-    /// Mutable pointer to the corresponding scheduler state.
-    ///
-    /// This object references a member of the scheduler_handle that yielded
-    /// this result_handle instance.  We need this direct access to clean up
-    /// after ourselves when the result is destroyed.
-    exec_data_map& all_exec_data;
+    std::thread::id tid;
 
     /// Test program data for this test case.
     model::test_program_ptr test_program;
@@ -613,19 +525,16 @@ struct engine::scheduler::result_handle::impl : utils::noncopyable {
     /// Constructor.
     ///
     /// \param generic_ Generic executor exit handle for this result handle.
-    /// \param [in,out] all_exec_data_ Global object keeping track of all active
-    ///     executions for an scheduler.  This is a pointer to a member of the
-    ///     scheduler_handle object.
     /// \param test_program_ Test program data for this test case.
     /// \param test_case_name_ Name of the test case.
     /// \param test_result_ The actual result of the test execution.
     impl(const executor::exit_handle generic_,
-         exec_data_map& all_exec_data_,
+         const std::thread::id tid_,
          const model::test_program_ptr test_program_,
          const std::string& test_case_name_,
          const model::test_result& test_result_) :
         generic(generic_),
-        all_exec_data(all_exec_data_),
+        tid(tid_),
         test_program(test_program_),
         test_case_name(test_case_name_),
         test_result(test_result_)
@@ -635,8 +544,6 @@ struct engine::scheduler::result_handle::impl : utils::noncopyable {
     /// Destructor.
     ~impl(void)
     {
-        LD(F("Removing %s from all_exec_data") % generic.original_pid());
-        all_exec_data.erase(generic.original_pid());
     }
 };
 
@@ -674,10 +581,10 @@ scheduler::result_handle::cleanup(void)
 /// Returns the original PID corresponding to this result.
 ///
 /// \return An exec_handle.
-int
-scheduler::result_handle::original_pid(void) const
+scheduler::exec_handle
+scheduler::result_handle::original_exec_handle(void) const
 {
-    return _pimpl->generic.original_pid();
+    return _pimpl->tid;
 }
 
 
@@ -768,12 +675,6 @@ struct engine::scheduler::scheduler_handle::impl : utils::noncopyable {
     /// Generic executor instance encapsulated by this one.
     executor::executor_handle generic;
 
-    /// Mapping of exec handles to the data required at run time.
-    exec_data_map all_exec_data;
-
-    /// Collection of test_exec_data objects.
-    typedef std::vector< const test_exec_data* > test_exec_data_vector;
-
     /// Constructor.
     impl(void) : generic(executor::setup())
     {
@@ -785,112 +686,49 @@ struct engine::scheduler::scheduler_handle::impl : utils::noncopyable {
     /// scheduler is abruptly terminated (aka if a signal is received).
     ~impl(void)
     {
-        const test_exec_data_vector tests_data = tests_needing_cleanup();
-
-        for (test_exec_data_vector::const_iterator iter = tests_data.begin();
-             iter != tests_data.end(); ++iter) {
-            const test_exec_data* test_data = *iter;
-
-            try {
-                sync_cleanup(test_data);
-            } catch (const std::runtime_error& e) {
-                LW(F("Failed to run cleanup routine for %s:%s on abrupt "
-                     "termination")
-                   % test_data->test_program->relative_path()
-                   % test_data->test_case_name);
-            }
-        }
     }
 
-    /// Finds any pending exec_datas that correspond to tests needing cleanup.
-    ///
-    /// \return The collection of test_exec_data objects that have their
-    /// needs_cleanup property set to true.
-    test_exec_data_vector
-    tests_needing_cleanup(void)
+    std::thread::id
+    track(std::thread thread)
     {
-        test_exec_data_vector tests_data;
-
-        for (exec_data_map::const_iterator iter = all_exec_data.begin();
-             iter != all_exec_data.end(); ++iter) {
-            const exec_data_ptr data = (*iter).second;
-
-            try {
-                test_exec_data* test_data = &dynamic_cast< test_exec_data& >(
-                    *data.get());
-                if (test_data->needs_cleanup) {
-                    tests_data.push_back(test_data);
-                    test_data->needs_cleanup = false;
-                }
-            } catch (const std::bad_cast& e) {
-                // Do nothing for cleanup_exec_data objects.
-            }
-        }
-
-        return tests_data;
+        std::lock_guard< std::mutex > guard(_mutex);
+        const std::thread::id id = thread.get_id();
+        threads[id] = std::move(thread);
+        return id;
     }
 
-    /// Cleans up a single test case synchronously.
-    ///
-    /// \param test_data The data of the previously executed test case to be
-    ///     cleaned up.
     void
-    sync_cleanup(const test_exec_data* test_data)
+    done(result_handle_ptr result)
     {
-        // The message in this result should never be seen by the user, but use
-        // something reasonable just in case it leaks and we need to pinpoint
-        // the call site.
-        model::test_result result(model::test_result_broken,
-                                  "Test case died abruptly");
-
-        const executor::exec_handle cleanup_handle = spawn_cleanup(
-            test_data->test_program, test_data->test_case_name,
-            test_data->user_config, test_data->exit_handle.get(),
-            result);
-        generic.wait(cleanup_handle);
+        std::lock_guard< std::mutex > guard(_mutex);
+        _results[std::this_thread::get_id()] = result;
+        _cv.notify_all();
     }
 
-    /// Forks and executes a test case cleanup routine asynchronously.
-    ///
-    /// \param test_program The container test program.
-    /// \param test_case_name The name of the test case to run.
-    /// \param user_config User-provided configuration variables.
-    /// \param body_handle The exit handle of the test case's corresponding
-    ///     body.  The cleanup will be executed in the same context.
-    /// \param body_result The result of the test case's corresponding body.
-    ///
-    /// \return A handle for the background operation.  Used to match the result
-    /// of the execution returned by wait_any() with this invocation.
-    executor::exec_handle
-    spawn_cleanup(const model::test_program_ptr test_program,
-                  const std::string& test_case_name,
-                  const config::tree& user_config,
-                  const executor::exit_handle& body_handle,
-                  const model::test_result& body_result)
+    result_handle_ptr
+    wait_any(void)
     {
-        generic.check_interrupt();
-
-        const std::shared_ptr< scheduler::interface > interface =
-            find_interface(test_program->interface_name());
-
-        LI(F("Spawning %s:%s (cleanup)") % test_program->absolute_path() %
-           test_case_name);
+        std::unique_lock< std::mutex > lock(_mutex);
+        _cv.wait(lock, [this]{return !_results.empty();});
 
-        const executor::exec_handle handle = generic.spawn_followup(
-            run_test_cleanup(interface, test_program, test_case_name,
-                             user_config),
-            body_handle, cleanup_timeout);
+        auto iter = _results.begin();
+        const std::thread::id id = iter->first;
+        result_handle_ptr result = iter->second;
+        _results.erase(iter);
 
-        const exec_data_ptr data(new cleanup_exec_data(
-            test_program, test_case_name, body_handle, body_result));
-        LD(F("Inserting %s into all_exec_data (cleanup)") % handle.pid());
-        INV_MSG(all_exec_data.find(handle.pid()) == all_exec_data.end(),
-                F("PID %s already in all_exec_data; not properly cleaned "
-                  "up or reused too fast") % handle.pid());;
-        all_exec_data.insert(exec_data_map::value_type(handle.pid(), data));
+        std::thread thread = std::move(threads[id]);
+        threads.erase(id);
 
-        return handle;
+        lock.unlock();
+        thread.join();
+        return result;
     }
+
+private:
+    std::mutex _mutex;
+    std::condition_variable _cv;
+    std::map< std::thread::id, result_handle_ptr > _results;
+    std::map< std::thread::id, std::thread > threads;
 };
 
 
@@ -1040,24 +878,13 @@ scheduler::scheduler_handle::list_tests(
 }
 
 
-/// Forks and executes a test case asynchronously.
-///
-/// Note that the caller needn't know if the test has a cleanup routine or not.
-/// If there indeed is a cleanup routine, we trigger it at wait_any() time.
-///
-/// \param test_program The container test program.
-/// \param test_case_name The name of the test case to run.
-/// \param user_config User-provided configuration variables.
-///
-/// \return A handle for the background operation.  Used to match the result of
-/// the execution returned by wait_any() with this invocation.
-scheduler::exec_handle
-scheduler::scheduler_handle::spawn_test(
-    const model::test_program_ptr test_program,
-    const std::string& test_case_name,
-    const config::tree& user_config)
+static void
+run_test(executor::executor_handle generic,
+         const model::test_program_ptr test_program,
+         const std::string& test_case_name,
+         const config::tree& user_config,
+         std::function< void(scheduler::result_handle_ptr) > done)
 {
-    _pimpl->generic.check_interrupt();
 
     const std::shared_ptr< scheduler::interface > interface = find_interface(
         test_program->interface_name());
@@ -1073,163 +900,148 @@ scheduler::scheduler_handle::spawn_test(
             "unprivileged_user");
     }
 
-    const executor::exec_handle handle = _pimpl->generic.spawn(
+    executor::exit_handle handle = generic.wait(generic.spawn(
         run_test_program(interface, test_program, test_case_name,
                          user_config),
         test_case.get_metadata().timeout(),
-        unprivileged_user);
-
-    const exec_data_ptr data(new test_exec_data(
-        test_program, test_case_name, interface, user_config));
-    LD(F("Inserting %s into all_exec_data") % handle.pid());
-    INV_MSG(
-        _pimpl->all_exec_data.find(handle.pid()) == _pimpl->all_exec_data.end(),
-        F("PID %s already in all_exec_data; not cleaned up or reused too fast")
-        % handle.pid());;
-    _pimpl->all_exec_data.insert(exec_data_map::value_type(handle.pid(), data));
-
-    return handle.pid();
-}
-
-
-/// Waits for completion of any forked test case.
-///
-/// Note that if the terminated test case has a cleanup routine, this function
-/// is the one in charge of spawning the cleanup routine asynchronously.
-///
-/// \return The result of the execution of a subprocess.  This is a dynamically
-/// allocated object because the scheduler can spawn subprocesses of various
-/// types and, at wait time, we don't know upfront what we are going to get.
-scheduler::result_handle_ptr
-scheduler::scheduler_handle::wait_any(void)
-{
-    _pimpl->generic.check_interrupt();
-
-    executor::exit_handle handle = _pimpl->generic.wait_any();
-
-    const exec_data_map::iterator iter = _pimpl->all_exec_data.find(
-        handle.original_pid());
-    exec_data_ptr data = (*iter).second;
-
-    utils::dump_stacktrace_if_available(data->test_program->absolute_path(),
-                                        _pimpl->generic, handle);
-
-    optional< model::test_result > result;
-    try {
-        test_exec_data* test_data = &dynamic_cast< test_exec_data& >(
-            *data.get());
-        LD(F("Got %s from all_exec_data") % handle.original_pid());
-
-        test_data->exit_handle = handle;
-
-        const model::test_case& test_case = test_data->test_program->find(
-            test_data->test_case_name);
-
-        result = test_case.fake_result();
-
-        if (!result && handle.status() && handle.status().get().exited() &&
-            handle.status().get().exitstatus() == exit_skipped) {
-            // If the test's process terminated with our magic "exit_skipped"
-            // status, there are two cases to handle.  The first is the case
-            // where the "skipped cookie" exists, in which case we never got to
-            // actually invoke the test program; if that's the case, handle it
-            // here.  The second case is where the test case actually decided to
-            // exit with the "exit_skipped" status; in that case, just fall back
-            // to the regular status handling.
-            const fs::path skipped_cookie_path = handle.control_directory() /
-                skipped_cookie;
-            std::ifstream input(skipped_cookie_path.c_str());
-            if (input) {
-                result = model::test_result(model::test_result_skipped,
-                                            utils::read_stream(input));
-                input.close();
-
-                // If we determined that the test needs to be skipped, we do not
-                // want to run the cleanup routine because doing so could result
-                // in errors.  However, we still want to run the cleanup routine
-                // if the test's body reports a skip (because actions could have
-                // already been taken).
-                test_data->needs_cleanup = false;
-            }
-        }
-        if (!result) {
-            result = test_data->interface->compute_result(
-                handle.status(),
-                handle.control_directory(),
-                handle.stdout_file(),
-                handle.stderr_file());
+        unprivileged_user));
+
+    utils::dump_stacktrace_if_available(test_program->absolute_path(),
+                                        generic, handle);
+
+    optional< model::test_result > result = test_case.fake_result();
+    bool needs_cleanup = test_case.get_metadata().has_cleanup();
+
+    if (!result && handle.status() && handle.status().get().exited() &&
+        handle.status().get().exitstatus() == exit_skipped) {
+        // If the test's process terminated with our magic "exit_skipped"
+        // status, there are two cases to handle.  The first is the case
+        // where the "skipped cookie" exists, in which case we never got to
+        // actually invoke the test program; if that's the case, handle it
+        // here.  The second case is where the test case actually decided to
+        // exit with the "exit_skipped" status; in that case, just fall back
+        // to the regular status handling.
+        const fs::path skipped_cookie_path = handle.control_directory() /
+            skipped_cookie;
+        std::ifstream input(skipped_cookie_path.c_str());
+        if (input) {
+            result = model::test_result(model::test_result_skipped,
+                                        utils::read_stream(input));
+            input.close();
+
+            // If we determined that the test needs to be skipped, we do not
+            // want to run the cleanup routine because doing so could result
+            // in errors.  However, we still want to run the cleanup routine
+            // if the test's body reports a skip (because actions could have
+            // already been taken).
+            needs_cleanup = false;
         }
-        INV(result);
+    }
+    if (!result) {
+        result = interface->compute_result(
+            handle.status(),
+            handle.control_directory(),
+            handle.stdout_file(),
+            handle.stderr_file());
+    }
+    INV(result);
 
-        if (!result.get().good()) {
-            append_files_listing(handle.work_directory(),
-                                 handle.stderr_file());
-        }
+    if (!result.get().good()) {
+        append_files_listing(handle.work_directory(),
+                             handle.stderr_file());
+    }
 
-        if (test_data->needs_cleanup) {
-            INV(test_case.get_metadata().has_cleanup());
-            // The test body has completed and we have processed it.  If there
-            // is a cleanup routine, trigger it now and wait for any other test
-            // completion.  The caller never knows about cleanup routines.
-            _pimpl->spawn_cleanup(test_data->test_program,
-                                  test_data->test_case_name,
-                                  test_data->user_config, handle, result.get());
-            test_data->needs_cleanup = false;
-
-            // TODO(jmmv): Chaining this call is ugly.  We'd be better off by
-            // looping over terminated processes until we got a result suitable
-            // for user consumption.  For the time being this is good enough and
-            // not a problem because the call chain won't get big: the majority
-            // of test cases do not have cleanup routines.
-            return wait_any();
-        }
-    } catch (const std::bad_cast& e) {
-        const cleanup_exec_data* cleanup_data =
-            &dynamic_cast< const cleanup_exec_data& >(*data.get());
-        LD(F("Got %s from all_exec_data (cleanup)") % handle.original_pid());
-
-        // Handle the completion of cleanup subprocesses internally: the caller
-        // is not aware that these exist so, when we return, we must return the
-        // data for the original test that triggered this routine.  For example,
-        // because the caller wants to see the exact same exec_handle that was
-        // returned by spawn_test.
-
-        const model::test_result& body_result = cleanup_data->body_result;
-        if (body_result.good()) {
-            if (!handle.status()) {
+    if (needs_cleanup) {
+        INV(test_case.get_metadata().has_cleanup());
+        executor::exit_handle cleanup_handle = generic.wait(
+            generic.spawn_followup(
+                run_test_cleanup(interface, test_program, test_case_name,
+                                 user_config),
+                handle, scheduler::cleanup_timeout));
+
+        if (result.get().good()) {
+            if (!cleanup_handle.status()) {
                 result = model::test_result(model::test_result_broken,
                                             "Test case cleanup timed out");
             } else {
-                if (!handle.status().get().exited() ||
-                    handle.status().get().exitstatus() != EXIT_SUCCESS) {
+                if (!cleanup_handle.status().get().exited() ||
+                    cleanup_handle.status().get().exitstatus() != EXIT_SUCCESS) {
                     result = model::test_result(
                         model::test_result_broken,
                         "Test case cleanup did not terminate successfully");
                 } else {
-                    result = body_result;
+                    //result = body_result;
                 }
             }
         } else {
-            result = body_result;
+            //result = body_result;
         }
+    }
+
+    std::shared_ptr< scheduler::result_handle::impl > result_handle_impl(
+        new scheduler::result_handle::impl(
+            handle, std::this_thread::get_id(), test_program, test_case_name, result.get()));
+    done(scheduler::result_handle_ptr(new scheduler::result_handle(result_handle_impl)));
+}
 
-        // Untrack the cleanup process.  This must be done explicitly because we
-        // do not create a result_handle object for the cleanup, and that is the
-        // one in charge of doing so in the regular (non-cleanup) case.
-        LD(F("Removing %s from all_exec_data (cleanup) in favor of %s")
-           % handle.original_pid()
-           % cleanup_data->body_exit_handle.original_pid());
-        _pimpl->all_exec_data.erase(handle.original_pid());
 
-        handle = cleanup_data->body_exit_handle;
+static void
+safe_run_test(executor::executor_handle generic,
+              const model::test_program_ptr test_program,
+              const std::string& test_case_name,
+              const config::tree& user_config,
+              std::function< void(scheduler::result_handle_ptr) > done)
+{
+    try {
+        run_test(generic, test_program, test_case_name, user_config, done);
+    } catch (const std::exception& e) {
+        // TODO(jmmv): Should report the exception as test breakage instead of
+        // leaking a nullptr to the caller.
+        LW(std::string("Test execution died: ") + e.what());
+        done(nullptr);
+    } catch (...) {
+        LW("Test execution died");
+        done(nullptr);
     }
-    INV(result);
+}
+
+
+/// Forks and executes a test case asynchronously.
+///
+/// Note that the caller needn't know if the test has a cleanup routine or not.
+/// If there indeed is a cleanup routine, we trigger it at wait_any() time.
+///
+/// \param test_program The container test program.
+/// \param test_case_name The name of the test case to run.
+/// \param user_config User-provided configuration variables.
+///
+/// \return A handle for the background operation.  Used to match the result of
+/// the execution returned by wait_any() with this invocation.
+scheduler::exec_handle
+scheduler::scheduler_handle::spawn_test(
+    const model::test_program_ptr test_program,
+    const std::string& test_case_name,
+    const config::tree& user_config)
+{
+    _pimpl->generic.check_interrupt();
+    std::thread thread(safe_run_test, _pimpl->generic, test_program, test_case_name,
+                       user_config,
+                       std::bind(&impl::done, _pimpl.get(), std::placeholders::_1));
+    return _pimpl->track(std::move(thread));
+}
+
+
+scheduler::result_handle_ptr
+scheduler::scheduler_handle::wait_any(void)
+{
+    return _pimpl->wait_any();
+}
+
 
-    std::shared_ptr< result_handle::impl > result_handle_impl(
-        new result_handle::impl(handle, _pimpl->all_exec_data,
-                                data->test_program, data->test_case_name,
-                                result.get()));
-    return result_handle_ptr(new result_handle(result_handle_impl));
+void
+get_result(scheduler::result_handle_ptr output, scheduler::result_handle_ptr result)
+{
+    output = result;
 }
 
 
@@ -1252,8 +1064,7 @@ scheduler::scheduler_handle::debug_test(
     const fs::path& stdout_target,
     const fs::path& stderr_target)
 {
-    const exec_handle exec_handle = spawn_test(
-        test_program, test_case_name, user_config);
+    spawn_test(test_program, test_case_name, user_config);
     result_handle_ptr result_handle = wait_any();
 
     // TODO(jmmv): We need to do this while the subprocess is alive.  This is
@@ -1274,7 +1085,7 @@ scheduler::scheduler_handle::debug_test(
         *output << utils::read_file(result_handle->stderr_file());
     }
 
-    INV(result_handle->original_pid() == exec_handle);
+//    INV(result_handle->original_pid() == exec_handle);
     return result_handle;
 }
 
diff --git a/engine/scheduler.hpp b/engine/scheduler.hpp
index 5a58bcf..3c82100 100644
--- a/engine/scheduler.hpp
+++ b/engine/scheduler.hpp
@@ -60,6 +60,7 @@
 #include <memory>
 #include <set>
 #include <string>
+#include <thread>
 
 #include "model/context_fwd.hpp"
 #include "model/metadata_fwd.hpp"
@@ -184,15 +185,15 @@ public:
 
 
 /// Container for all test termination data and accessor to cleanup operations.
-class result_handle {
-protected:
+class result_handle : utils::noncopyable {
+public:  // XXX protected:
     struct impl;
 
-private:
-    /// Pointer to internal implementation.
+public:  // XXX private:
+    /// Pointer to internal implementation of the base type.
     std::shared_ptr< impl > _pimpl;
 
-protected:
+public:  // XXX protected:
     friend class scheduler_handle;
     result_handle(std::shared_ptr< impl >);
 
@@ -201,7 +202,7 @@ public:
 
     void cleanup(void);
 
-    int original_pid(void) const;
+    exec_handle original_exec_handle(void) const;
     const utils::datetime::timestamp& start_time() const;
     const utils::datetime::timestamp& end_time() const;
     utils::fs::path work_directory(void) const;
diff --git a/engine/scheduler_fwd.hpp b/engine/scheduler_fwd.hpp
index f61b084..b486f5d 100644
--- a/engine/scheduler_fwd.hpp
+++ b/engine/scheduler_fwd.hpp
@@ -33,6 +33,7 @@
 #define ENGINE_SCHEDULER_FWD_HPP
 
 #include <memory>
+#include <thread>
 
 namespace engine {
 namespace scheduler {
@@ -42,13 +43,12 @@ namespace scheduler {
 ///
 /// TODO(jmmv): Might be worth to drop altogether and just use "int".  The type
 /// difference with executor::exec_handle is confusing.
-typedef int exec_handle;
+typedef std::thread::id exec_handle;
 
 
 class scheduler_handle;
 class interface;
 class result_handle;
-class test_result_handle;
 
 
 /// Pointer to a dynamically-allocated result_handle.
diff --git a/engine/scheduler_test.cpp b/engine/scheduler_test.cpp
index 86be2fb..dafa129 100644
--- a/engine/scheduler_test.cpp
+++ b/engine/scheduler_test.cpp
@@ -578,7 +578,7 @@ ATF_TEST_CASE_BODY(integration__run_one)
         program, "exit 41", user_config);
 
     scheduler::result_handle_ptr result_handle = handle.wait_any();
-    ATF_REQUIRE_EQ(exec_handle, result_handle->original_pid());
+    ATF_REQUIRE_EQ(exec_handle, result_handle->original_exec_handle());
     ATF_REQUIRE_EQ(model::test_result(model::test_result_passed, "Exit 41"),
                    result_handle->test_result());
     result_handle->cleanup();
@@ -597,10 +597,12 @@ ATF_TEST_CASE_BODY(integration__run_many)
 
     scheduler::scheduler_handle handle = scheduler::setup();
 
-    // We mess around with the "current time" below, so make sure the tests do
-    // not spuriously exceed their deadline by bumping it to a large number.
-    const model::metadata infinite_timeout = model::metadata_builder()
-        .set_timeout(datetime::delta(1000000L, 0)).build();
+    const datetime::timestamp start_time = datetime::timestamp::now();
+
+    // THIS IS RACY. OUR SUBPROCESSES GET STUCK AT RANDOM POINTS BECAUSE, WELL,
+    // WE ARE FORKING AND THEIR STATE IS INCONSISTENT.  MUST AUDIT ALL CODE TO
+    // ENSURE FORK+EXEC PAIRS DON'T REQUIRE ANY ASYNC-UNSAFE FUNCTIONS, NOR
+    // MEMORY ALLOCATIONS...
 
     std::size_t total_tests = 0;
     std::map< scheduler::exec_handle, model::test_program_ptr >
@@ -616,57 +618,52 @@ ATF_TEST_CASE_BODY(integration__run_many)
         const model::test_program_ptr program = model::test_program_builder(
             "mock", fs::path(F("program-%s") % i),
             fs::current_path(), "the-suite")
-            .set_metadata(infinite_timeout)
             .add_test_case(test_case_0)
             .add_test_case(test_case_1)
             .add_test_case(test_case_2)
             .build_ptr();
 
-        const datetime::timestamp start_time = datetime::timestamp::from_values(
-            2014, 12, 8, 9, 40, 0, i);
-
         scheduler::exec_handle exec_handle;
 
-        datetime::set_mock_now(start_time);
         exec_handle = handle.spawn_test(program, test_case_0, user_config);
+        ATF_REQUIRE(exp_test_programs.find(exec_handle)
+                    == exp_test_programs.end());
         exp_test_programs.insert(std::make_pair(exec_handle, program));
         exp_test_case_names.insert(std::make_pair(exec_handle, test_case_0));
-        exp_start_times.insert(std::make_pair(exec_handle, start_time));
         exp_exit_statuses.insert(std::make_pair(exec_handle, i * 3));
         ++total_tests;
 
-        datetime::set_mock_now(start_time);
         exec_handle = handle.spawn_test(program, test_case_1, user_config);
+        ATF_REQUIRE(exp_test_programs.find(exec_handle)
+                    == exp_test_programs.end());
         exp_test_programs.insert(std::make_pair(exec_handle, program));
         exp_test_case_names.insert(std::make_pair(exec_handle, test_case_1));
-        exp_start_times.insert(std::make_pair(exec_handle, start_time));
         exp_exit_statuses.insert(std::make_pair(exec_handle, i * 3 + 1));
         ++total_tests;
 
-        datetime::set_mock_now(start_time);
         exec_handle = handle.spawn_test(program, test_case_2, user_config);
+        ATF_REQUIRE(exp_test_programs.find(exec_handle)
+                    == exp_test_programs.end());
         exp_test_programs.insert(std::make_pair(exec_handle, program));
         exp_test_case_names.insert(std::make_pair(exec_handle, test_case_2));
-        exp_start_times.insert(std::make_pair(exec_handle, start_time));
         exp_exit_statuses.insert(std::make_pair(exec_handle, i * 3 + 2));
         ++total_tests;
     }
 
     for (std::size_t i = 0; i < total_tests; ++i) {
-        const datetime::timestamp end_time = datetime::timestamp::from_values(
-            2014, 12, 8, 9, 50, 10, i);
-        datetime::set_mock_now(end_time);
         scheduler::result_handle_ptr result_handle = handle.wait_any();
+        const datetime::timestamp end_time = datetime::timestamp::now();
+
+        if (result_handle == nullptr)
+            continue; // XXX
 
         const scheduler::exec_handle exec_handle =
-            result_handle->original_pid();
+            result_handle->original_exec_handle();
 
         const model::test_program_ptr test_program = exp_test_programs.find(
             exec_handle)->second;
         const std::string& test_case_name = exp_test_case_names.find(
             exec_handle)->second;
-        const datetime::timestamp& start_time = exp_start_times.find(
-            exec_handle)->second;
         const int exit_status = exp_exit_statuses.find(exec_handle)->second;
 
         ATF_REQUIRE_EQ(model::test_result(model::test_result_passed,
@@ -676,8 +673,8 @@ ATF_TEST_CASE_BODY(integration__run_many)
         ATF_REQUIRE_EQ(test_program, result_handle->test_program());
         ATF_REQUIRE_EQ(test_case_name, result_handle->test_case_name());
 
-        ATF_REQUIRE_EQ(start_time, result_handle->start_time());
-        ATF_REQUIRE_EQ(end_time, result_handle->end_time());
+        ATF_REQUIRE(start_time <= result_handle->start_time());
+        ATF_REQUIRE(end_time >= result_handle->end_time());
 
         result_handle->cleanup();
 
@@ -738,7 +735,7 @@ ATF_TEST_CASE_BODY(integration__parameters_and_output)
 
     scheduler::result_handle_ptr result_handle = handle.wait_any();
 
-    ATF_REQUIRE_EQ(exec_handle, result_handle->original_pid());
+    ATF_REQUIRE_EQ(exec_handle, result_handle->original_exec_handle());
     ATF_REQUIRE_EQ(program, result_handle->test_program());
     ATF_REQUIRE_EQ("print_params", result_handle->test_case_name());
     ATF_REQUIRE_EQ(model::test_result(model::test_result_passed, "Exit 0"),
diff --git a/utils/datetime.cpp b/utils/datetime.cpp
index ae3fdb6..08dac18 100644
--- a/utils/datetime.cpp
+++ b/utils/datetime.cpp
@@ -34,6 +34,7 @@ extern "C" {
 #include <time.h>
 }
 
+#include <mutex>
 #include <stdexcept>
 
 #include "utils/format/macros.hpp"
@@ -50,6 +51,9 @@ using utils::optional;
 namespace {
 
 
+std::mutex mutex;
+
+
 /// Fake value for the current time.
 static optional< datetime::timestamp > mock_now = none;
 
@@ -362,8 +366,11 @@ datetime::timestamp::from_values(const int year, const int month,
 datetime::timestamp
 datetime::timestamp::now(void)
 {
-    if (mock_now)
-        return mock_now.get();
+    {
+        std::lock_guard< std::mutex > lock(mutex);
+        if (mock_now)
+            return mock_now.get();
+    }
 
     ::timeval data;
     {
@@ -437,6 +444,7 @@ datetime::set_mock_now(const int year, const int month,
                        const int minute, const int second,
                        const int microsecond)
 {
+    std::lock_guard< std::mutex > lock(mutex);
     mock_now = timestamp::from_values(year, month, day, hour, minute, second,
                                       microsecond);
 }
@@ -448,6 +456,7 @@ datetime::set_mock_now(const int year, const int month,
 void
 datetime::set_mock_now(const timestamp& mock_now_)
 {
+    std::lock_guard< std::mutex > lock(mutex);
     mock_now = mock_now_;
 }
 
diff --git a/utils/logging/operations.cpp b/utils/logging/operations.cpp
index d71d24d..2d0ba92 100644
--- a/utils/logging/operations.cpp
+++ b/utils/logging/operations.cpp
@@ -32,6 +32,8 @@ extern "C" {
 #include <unistd.h>
 }
 
+#include <atomic>
+#include <mutex>
 #include <stdexcept>
 #include <string>
 #include <utility>
@@ -126,6 +128,12 @@ struct global_state {
 /// this state never gets cleaned up.
 static struct global_state* globals_singleton = NULL;
 
+// Must be recursive because the code we call to populate our global state may
+// want to log as well.
+static std::recursive_mutex globals_mutex;
+
+static std::atomic_int globals_owner(::getpid());
+
 
 /// Gets the singleton instance of global_state.
 ///
@@ -173,6 +181,10 @@ level_to_char(const logging::level level)
 fs::path
 logging::generate_log_name(const fs::path& logdir, const std::string& progname)
 {
+    if (::getpid() != globals_owner)
+        return fs::path("POISONED");
+
+    std::lock_guard< std::recursive_mutex > lock(globals_mutex);
     struct global_state* globals = get_globals();
 
     if (!globals->first_timestamp)
@@ -196,6 +208,10 @@ void
 logging::log(const level message_level, const char* file, const int line,
              const std::string& user_message)
 {
+    if (::getpid() != globals_owner)
+        return;
+
+    std::lock_guard< std::recursive_mutex > lock(globals_mutex);
     struct global_state* globals = get_globals();
 
     const datetime::timestamp now = datetime::timestamp::now();
@@ -235,6 +251,10 @@ logging::log(const level message_level, const char* file, const int line,
 void
 logging::set_inmemory(void)
 {
+    if (::getpid() != globals_owner)
+        return;
+
+    std::lock_guard< std::recursive_mutex > lock(globals_mutex);
     struct global_state* globals = get_globals();
 
     globals->auto_set_persistency = false;
@@ -265,6 +285,10 @@ logging::set_inmemory(void)
 void
 logging::set_persistency(const std::string& new_level, const fs::path& path)
 {
+    if (::getpid() != globals_owner)
+        return;
+
+    std::lock_guard< std::recursive_mutex > lock(globals_mutex);
     struct global_state* globals = get_globals();
 
     globals->auto_set_persistency = false;
diff --git a/utils/process/deadline_killer.cpp b/utils/process/deadline_killer.cpp
index 63183d2..13ae33e 100644
--- a/utils/process/deadline_killer.cpp
+++ b/utils/process/deadline_killer.cpp
@@ -38,9 +38,12 @@
 #include "utils/logging/macros.hpp"
 #include "utils/process/operations.hpp"
 #include "utils/sanity.hpp"
+#include "utils/signals/exceptions.hpp"
+#include "utils/signals/interrupts.hpp"
 
 namespace datetime = utils::datetime;
 namespace process = utils::process;
+namespace signals = utils::signals;
 
 
 namespace {
@@ -90,21 +93,28 @@ extract_pids_to_kill(void)
 static void
 killer_thread(void)
 {
-    for (;;) {
-        const std::set< int > pids_to_kill = extract_pids_to_kill();
-        for (auto pid : pids_to_kill) {
-            process::terminate_group(pid);
+    try {
+        for (;;) {
+            const std::set< int > pids_to_kill = extract_pids_to_kill();
+            for (auto pid : pids_to_kill) {
+                process::terminate_group(pid);
+            }
+
+            // TODO(jmmv): Instead of sleeping in a loop perpetually when there
+            // are no instances of deadline_killer left behind, we could block
+            // until a new one is created... or we could even shut the thread
+            // down.  Unclear if these "improvements" are worthwhile because
+            // this class is used to control the execution of all tests and,
+            // thorough the lifetime of a single Kyua run, there is a lot of
+            // churn in deadline_killer creations.  The overhead of controlling
+            // when or when not to sleep could be worse than the once-a-second
+            // wakeups.
+            std::this_thread::sleep_for(std::chrono::seconds(1));
+
+            signals::check_interrupt();
         }
-
-        // TODO(jmmv): Instead of sleeping in a loop perpetually when there are
-        // no instances of deadline_killer left behind, we could block until a
-        // new one is created... or we could even shut the thread down.  Unclear
-        // if these "improvements" are worthwhile because this class is used to
-        // control the execution of all tests and, thorough the lifetime of a
-        // single Kyua run, there is a lot of churn in deadline_killer
-        // creations.  The overhead of controlling when or when not to sleep
-        // could be worse than the once-a-second wakeups.
-        std::this_thread::sleep_for(std::chrono::seconds(1));
+    } catch (const signals::interrupted_error& e) {
+        // Exit cleanly.
     }
 }
 
diff --git a/utils/process/executor.cpp b/utils/process/executor.cpp
index 5a1d6a7..fd3695a 100644
--- a/utils/process/executor.cpp
+++ b/utils/process/executor.cpp
@@ -42,6 +42,7 @@ extern "C" {
 #include <fstream>
 #include <map>
 #include <memory>
+#include <mutex>
 #include <stdexcept>
 
 #include "utils/datetime.hpp"
@@ -83,7 +84,13 @@ static const char* work_directory_template = PACKAGE_TARNAME ".XXXXXX";
 
 
 /// Mapping of active subprocess PIDs to their execution data.
-typedef std::map< int, executor::exec_handle > exec_handles_map;
+struct exec_handles_map {
+    std::mutex mutex;
+
+    typedef std::map< int, executor::exec_handle > map_type;
+    typedef map_type::value_type value_type;
+    map_type map;
+};
 
 
 }  // anonymous namespace
@@ -380,7 +387,8 @@ struct utils::process::executor::exit_handle::impl : utils::noncopyable {
         // cleaning above, is fine (albeit a bit confusing).  Note that "another
         // owner" refers to a handle for a different PID, so that handle will be
         // the one issuing the cleanup.
-        all_exec_handles.erase(original_pid);
+        std::lock_guard< std::mutex > guard(all_exec_handles.mutex);
+        all_exec_handles.map.erase(original_pid);
         cleaned = true;
     }
 };
@@ -577,10 +585,10 @@ struct utils::process::executor::executor_handle::impl : utils::noncopyable {
     {
         PRE(!cleaned);
 
-        for (exec_handles_map::const_iterator iter = all_exec_handles.begin();
-             iter != all_exec_handles.end(); ++iter) {
-            const int& pid = (*iter).first;
-            const exec_handle& data = (*iter).second;
+        std::lock_guard< std::mutex > guard(all_exec_handles.mutex);
+        for (auto iter : all_exec_handles.map) {
+            const int& pid = iter.first;
+            const exec_handle& data = iter.second;
 
             process::terminate_group(pid);
             int status;
@@ -596,7 +604,7 @@ struct utils::process::executor::executor_handle::impl : utils::noncopyable {
                    data.control_directory() % e.what());
             }
         }
-        all_exec_handles.clear();
+        all_exec_handles.map.clear();
 
         try {
             // The following only causes the work directory to be deleted, not
@@ -627,7 +635,8 @@ struct utils::process::executor::executor_handle::impl : utils::noncopyable {
 
         process::terminate_group(status.dead_pid());
 
-        const exec_handles_map::iterator iter = all_exec_handles.find(
+        std::lock_guard< std::mutex > guard(all_exec_handles.mutex);
+        const exec_handles_map::map_type::iterator iter = all_exec_handles.map.find(
             original_pid);
         exec_handle& data = (*iter).second;
         const bool killed = data._pimpl->timer.unschedule();
@@ -764,11 +773,12 @@ executor::executor_handle::spawn_post(
             timeout,
             unprivileged_user,
             detail::refcnt_t(new detail::refcnt_t::element_type(0)))));
-    INV_MSG(_pimpl->all_exec_handles.find(handle.pid()) ==
-            _pimpl->all_exec_handles.end(),
+    std::lock_guard< std::mutex > guard(_pimpl->all_exec_handles.mutex);
+    INV_MSG(_pimpl->all_exec_handles.map.find(handle.pid()) ==
+            _pimpl->all_exec_handles.map.end(),
             F("PID %s already in all_exec_handles; not properly cleaned "
               "up or reused too fast") % handle.pid());;
-    _pimpl->all_exec_handles.insert(exec_handles_map::value_type(
+    _pimpl->all_exec_handles.map.insert(exec_handles_map::value_type(
         handle.pid(), handle));
     LI(F("Spawned subprocess with exec_handle %s") % handle.pid());
     return handle;
@@ -807,11 +817,12 @@ executor::executor_handle::spawn_followup_post(
             timeout,
             base.unprivileged_user(),
             base.state_owners())));
-    INV_MSG(_pimpl->all_exec_handles.find(handle.pid()) ==
-            _pimpl->all_exec_handles.end(),
+    std::lock_guard< std::mutex > guard(_pimpl->all_exec_handles.mutex);
+    INV_MSG(_pimpl->all_exec_handles.map.find(handle.pid()) ==
+            _pimpl->all_exec_handles.map.end(),
             F("PID %s already in all_exec_handles; not properly cleaned "
               "up or reused too fast") % handle.pid());;
-    _pimpl->all_exec_handles.insert(exec_handles_map::value_type(
+    _pimpl->all_exec_handles.map.insert(exec_handles_map::value_type(
         handle.pid(), handle));
     LI(F("Spawned subprocess with exec_handle %s") % handle.pid());
     return handle;
