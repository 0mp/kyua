@c Copyright 2010 Google Inc.
@c All rights reserved.
@c
@c Redistribution and use in source and binary forms, with or without
@c modification, are permitted provided that the following conditions are
@c met:
@c
@c * Redistributions of source code must retain the above copyright
@c   notice, this list of conditions and the following disclaimer.
@c * Redistributions in binary form must reproduce the above copyright
@c   notice, this list of conditions and the following disclaimer in the
@c   documentation and/or other materials provided with the distribution.
@c * Neither the name of Google Inc. nor the names of its contributors
@c   may be used to endorse or promote products derived from this software
@c   without specific prior written permission.
@c
@c THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
@c "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
@c LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
@c A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
@c OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
@c SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
@c LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
@c DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
@c THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
@c (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
@c OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

@node Test interfaces
@chapter Test program and test case interfaces

@cindex test interface
@cindex test protocol

The main purpose of the runtime engine of @command{kyua} is to run
test programs.  The test programs recognized by the runtime engine are
regular binaries that implement a particular interface.  This
interface allows the runtime engine to communicate with the test
programs to request the execution of test cases and to collect their
results.

At the moment, Kyua does not provide its own libraries to implement
test programs and, therefore, it relies on the ATF libraries.  This is
to simplify the transition from @command{atf-run} to @command{kyua},
as the same test programs can be used with both tools.

The following sections describe what these interfaces are.

@menu
* ATF Test Interface:: The interface of ATF-based test programs.
* Plain Test Interface:: The interface of exit code-based test programs.
@end menu

@node ATF Test Interface
@section The ATF Test Interface

@cindex atf test interface
@cindex test interface, atf

The interface of ATF test programs is the interface of the test
programs linked to the @samp{atf-c}, @samp{atf-c++} and @samp{atf-sh}
libraries provided by ATF.

The ATF interface can be understood as the mechanisms used by test
programs to communicate with the runtime engine as well as the
assumptions that test programs and test cases can make while running.

A test case is the most basic part of a test suite.  A test case is
supposed to reproduce one, and only one, scenario.  For example: if
the item under test was a function, the test case would provide a
single set of input parameters to the function and check its output;
If the item under test was a binary, the test case would provide a
single set of arguments to the program and check its behavior.

@menu
* ATF Test Case Parts::
* ATF Metadata Properties::
* ATF Configuration Properties::
* ATF Results::
* ATF Isolation::
* ATF Test Programs::
@end menu

@node ATF Test Case Parts
@subsection Test case parts

@cindex atf test case parts
@cindex test case parts, atf

Test cases have three parts:

@table @asis
@item Head
Programmatically defines metadata properties.  The head must not
perform any other thing than defining such properties.  In particular,
no testing whatsoever can happen in the head.  (Ideally the definition
of metadata properties would not happen programmatically.)

@item Body
The actual test case which performs any desired testing and reports a
result.  The body is executed by the runtime engine in a deterministic
way; see the isolation section below.

@item Cleanup
An optional cleanup routine.  Note that the runtime engine will
attempt to clean up the work directory automatically, so this routine
should only be provided in cases where the test modifies system-wide
state not known by the runtime engine.  The cleanup part is executed
in the same directory as the body.  However, the body and the cleanup
parts @strong{do not share the same process space}; the only way to
pass data around from the body to the cleanup is by means of files in
the work directory.
@end table

@node ATF Metadata Properties
@subsection Metadata properties

@cindex atf test case metadata properties
@cindex metadata properties, atf

The following test case metadata properties must be exported in the
test case list for every test case:

@table @samp
@item ident
Single-word string.  The name of the test case.  Must be unique within
the test program.
@end table

The following test case metadata properties may be exported in the
test case list for every test case:

@table @samp
@item descr
Multi-word string.  A textual description for the test case.  Usually,
providing a descriptive identifier is better than providing a textual
description.

@item has.cleanup
Boolean.  Whether the test case defines a cleanup routine or not.

@item require.arch
Whitespace separated list of the architectures required by the test
case.  If defined, the test case is skipped unless the host
architecture matches any of the values defined in this property.

@item require.config
Whitespace separated list of configuration variable names.  The list
of configuration variables that must be defined.  The test is skipped
if any of these is missing.

@item require.files
Whitespace separated list of absolute paths to installed files.  If
any of these files is not found, the test case is skipped.

@item require.machine
Whitespace separated list of the machine types required by the test
case.  If defined, the test case is skipped unless the host machine
type matches any of the values defined in this property.

@item require.progs
Whitespace separated list of program names (either absolute names or
base names).  If any of these programs is not found, the test case is
skipped.

@item require.user
One of @samp{root}, @samp{unprivileged}. If @samp{root}, the test case
must be run as the superuser or otherwise it is skipped.  If
@samp{unprivileged}, the test case must be run as an unprivileged user
or else it is skipped.

@item timeout
Integer.  The amount of seconds the test case can run for before it is
killed by the runtime engine.
@end table

@node ATF Configuration Properties
@subsection Configuration properties

@cindex atf test case configuration properties
@cindex configuration properties, atf

The following properties may be defined by the runtime engine and are
propagated to the test cases:

@table @samp
@item unprivileged-user
String, optional.  Specifies the name of the user under which tests
that set @samp{require.user=unprivileged} are executed.
@end table

@node ATF Results
@subsection Results

@cindex atf test case results
@cindex results, atf

A test case must always report a result by creating the results file
specified through the @option{-r} flag.  For convenience when running
test cases without the runtime engine, this file may point to
@file{/dev/stdout} or @file{/dev/stderr} in which case the file must
not be created (because the creation will fail).

Aside from creating the results file, the process in which the test
case runs must terminate in particular ways for the test result to be
considered valid.

If the test case fails to create the test result, if the test result
is created but contains an invalid syntax, or if the termination
status of the process does not match the requirements of the test
result, the runtime engine marks the test case as @samp{broken}.  Note
that the @samp{broken} state is decided by the runtime engine; a test
case cannot report itself as @samp{broken}.

The general syntax for the results file is as follows:

@verbatim
<status>[[(int)]: reason]
@end verbatim

The following results are allowed:

@table @samp
@item expected_death
The process is expected to terminate either due to a clean call to
@samp{exit(3)} or due to the reception of a signal.  The contents of
the file are @samp{expected_death: <reason>\n}.  Example:
@samp{expected_death: Calling libdofoo() breaks due to bug xyz}.

@item expected_exit
The process is expected to terminate cleanly.  The contents of the
file are @samp{expected_exit: <reason>} if the exit code is irrelevant
or @samp{expected_exit(<exitcode>): <reason>} if the process must
terminate with a given exit code.  Examples: @samp{expected_exit:
Calling bar() exits but it should not} or @samp{expected_exit(123):
Calling bar() exits with a particular code but it should not}.

@item expected_failure
The process must exit cleanly with an @code{EXIT_SUCCESS} exit code.
The contents of the file are @samp{expected_failure: <reason>\n}.
Example: @samp{expected_failure: 2 + 2 = 3}.

@item expected_signal
The process is expected to terminate due to the reception of a signal.
The contents of the file are @samp{expected_signal: <reason>} if the
signal number is irrelevant or @samp{expected_signal(<signalno>):
<reason>} if the process must terminate due to a particular signal.
Examples: @samp{expected_signal: Calling bar() crashes} or
@samp{expected_signal(1): Calling bar() kills ourselves due to
unhandled SIGHUP; see bug xyz}.

@item expected_timeout
The process is expected to hang for longer than its @samp{timeout}
metadata property.  Only the runtime engine can control this situation
because the runtime engine is the one implementing the timeout
functionality.

@item failed
The process must exit cleanly with an @code{EXIT_FAILURE} exit code.
The contents of the file are @samp{failed: <reason>\n}.  Example:
@samp{failed: Failed on purpose\n}.

@item passed
The process must exit cleanly with an @code{EXIT_SUCCESS} exit code.
The contents of the file are @samp{passed\n}.

@item skipped
The process must exit cleanly with an @code{EXIT_SUCCESS} exit code.
The contents of the file are @samp{skipped: <reason>\n}.  Example:
@samp{skipped: Skipped because the foo is not present\n}.
@end table

@node ATF Isolation
@subsection Isolation

@cindex atf test case isolation
@cindex isolation, atf

The runtime engine attempts to isolate test cases from other test
cases in the same test program and from the rest of the system by
performing what is called @emph{test case isolation}.

Whenever the user runs a test program binary by hand (i.e. not through
@command{kyua}), the test program will print a warning message stating
that test case isolation does not work and therefore the program may
cause side-effects and/or report invalid values.

The runtime engine (@command{kyua} in our case) must set the
@env{__RUNNING_INSIDE_ATF_RUN} environment variable to the magic value
@samp{internal-yes-value} to tell the test programs that they are
being run with isolation enabled.

The test case isolation performs the following:

@itemize
@item
Process space: Each test case body and cleanup routines are executed
in independent processes.  Corollary: the test case can do whatever it
wants to the current process (such as modifying global variables)
without having to undo such changes.

@item
Process group: The test case body and cleanup are executed in their
own process groups.  Should they spawn any children, such children
should maintain the same process group.  This is done to allow the
runtime engine to kill the whole process subtree once the test case
finishes (or if the test case hangs).

@item
Work directory: The test case body and its cleanup (if any) are
executed in a temporary directory automatically created by the runtime
engine.  This temporary directory is shared among the body and cleanup
parts of a single test case but is completely separate from the
temporary directories of other tests.  Corollary: the test case body
and cleanup routines can write to their current directory without
bothering to clean any files and/or directories they create.  The
runtime engine takes care to recursively delete the temporary
directories after the execution of a test case.  Any file systems
mounted within the temporary directory will be unmounted if possible.

@item
Home directory: The @env{HOME} environment variable is set to the absolute
path of the work directory.

@item
Umask: The value of the umask is set to 0022.

@item
Environment: The @env{LANG}, @env{LC_ALL}, @env{LC_COLLATE},
@env{LC_CTYPE}, @env{LC_MESSAGES}, @env{LC_MONETARY},
@env{LC_NUMERIC} and @env{LC_TIME} variables are unset.
The @env{TZ} variable is set to @samp{UTC}.
@end itemize

@node ATF Test Programs
@subsection Test programs

@cindex atf test programs
@cindex test programs, atf

A test program is, simply put, a collection of related test cases.
The test program can be seen as a command-line dispatcher for the test
cases.

@menu
* ATF Generic Requirements::
* ATF List Test Cases::
* ATF Run Test Case Body::
* ATF Run Test Case Cleanup::
@end menu

@node ATF Generic Requirements
@subsubsection Generic requirements

A test program must provide one or more test cases.  If it does not
contain any test case, the runtime system will report it as invalid.

@node ATF List Test Cases
@subsubsection Command-line interface: List test cases

@cindex list test cases, atf
@cindex test cases list, atf

Test programs expose their list of test cases in a machine parseable
format.  The runtime engine obtains the list of test cases to know
what tests to run and to know how to set up the environment of each
test prior execution.  The test program must not do any test when
asked to dump its test case list.

The generic syntax to obtain the list of test cases included in a test
program is:

@verbatim
<test-program> -l
@end verbatim

The list of test cases follows the following format:

@verbatim
LIST ::= HEADER NEWLINE TEST_CASES

HEADER ::= 'Content-Type: application/X-atf-tp; version="1"'
NEWLINE ::= '\n'
TEST_CASES ::= TEST_CASE | TEST_CASE NEWLINE TEST_CASES

TEST_CASE ::= IDENT_PROPERTY PROPERTIES
IDENT_PROPERTY ::= 'ident' DELIM STRING NEWLINE
DELIM ::= ': '

PROPERTIES ::= PROPERTY | PROPERTY PROPERTIES
PROPERTY ::= PROPERTY_NAME DELIM STRING NEWLINE
PROPERTY_NAME ::= (see below)
@end verbatim

An example:

@verbatim
Content-Type: application/X-atf-tp; version="1"

ident: addition
descr: Tests that the addition() function works

ident: subtraction
descr: Tests that the subtraction() function works

ident: remove
descr: Tests removing files
require.root: true
timeout: 50
has.cleanup: true
@end verbatim

@node ATF Run Test Case Body
@subsubsection Command-line interface: Run a test case body

@cindex run test case body, atf

The syntax to run a test case body part is:

@verbatim
<test-program> [-r resfile] [-s srcdir] [-v var=value]* <test-case>[:body]
@end verbatim

This must run the test case body ``as is'', without any attempt of
isolating it from the rest of the system.  It is the responsibility of
the runtime engine to do such isolation.

The runtime engine always passes the path of a nonexistent file to
@option{-r}, which must be created by the test case; and always passes
an absolute path to the @option{-s} flag pointing to the directory
containing the test program executable.

The runtime engine shall pass any configuration variables it wants
through the @option{-v} flag, and these can be later inspected by the
test case at will.

A note to users: if you run the test case by hand (not through
@command{kyua} or @command{atf-run}) from the command line, none of
the isolation features described in the isolation section apply.  This
means that the test case can (and probably will) write to the current
directory and leave garbage behind.  Also, given that the test case is
executed without e.g. clearing the environment, the results of the
test case may differ from those obtained when running the test case
inside the runtime engine.  @strong{Only use this for debugging
purposes} (i.e. to run the test case code under GDB).

@node ATF Run Test Case Cleanup
@subsubsection Command-line interface: Run a test case cleanup

@cindex run test case cleanup, atf

The syntax to run a test case cleanup part is:

@verbatim
<test-program> [-s srcdir] [-v var=value]* <test-case>:cleanup
@end verbatim

This can only be performed if and only if the test case sets the
@samp{has.cleanup} property to true.  Otherwise the behavior of
executing the cleanup part is undefined.

The same rules for @option{-s} and @option{-v} apply as to when
running the body.

The cleanup part must be executed in the same directory as the body
but in a separate process space.  The only way for test cases to
transfer state (if any) from the body to the cleanup routine is by
means of files in the current directory.

The cleanup part does not have to worry about deleting temporary files
created in the current directory.  The runtime engine does this
automatically.

@node Plain Test Interface
@section The Plain Test Interface

@cindex plain test interface
@cindex test interface, plain

The @emph{plain} test interface is the interface of test programs that
return their pass/fail status as an exit code.  While simple, this
interface is what legacy test programs use.

Kyua supports this interface for two main reasons: first, to simplify
the incorporation of legacy test programs into a Kyua test suite; and,
second, to ensure that the Kyua run-time engine does not become tied
to a particular test interface.

The results of a plain test are one of the following:

@table @samp
@item passed
If the test program exits with a success exit code; i.e. 0.

@item failed
If the test program exits with a failure exit code; i.e. not 0.

@item broken
If the test program exits due to any other reason (e.g. it crashes) or
if it fails to be executed.
@end table

Plain test programs are executed with the same isolation features as
ATF test programs; see @xref{ATF Isolation}.
