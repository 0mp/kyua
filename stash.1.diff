commit 95cca22e91970718b6001e59a2b432ea53bb415d
Merge: 62114e2 c486b8a
Author: Julio Merino <jmmv@google.com>
Date:   Fri Mar 3 15:36:12 2017 -0800

    WIP on threads: 62114e2 Enable C++11 support

diff --cc cli/main.cpp
index 531c252,531c252..225a74e
--- a/cli/main.cpp
+++ b/cli/main.cpp
@@@ -76,6 -76,6 +76,7 @@@ extern "C" 
  #include "utils/optional.ipp"
  #include "utils/sanity.hpp"
  #include "utils/signals/exceptions.hpp"
++#include "utils/signals/interrupts.hpp"
  
  namespace cmdline = utils::cmdline;
  namespace config = utils::config;
@@@ -289,8 -289,8 +290,7 @@@ cli::main(cmdline::ui* ui, const int ar
          // Re-deliver the interruption signal to self so that we terminate with
          // the right status.  At this point we should NOT have any custom signal
          // handlers in place.
--        ::kill(getpid(), e.signo());
--        LD("Interrupt signal re-delivery did not terminate program");
++        signals::redeliver_to_exit(e.signo());
          // If we reach this, something went wrong because we did not exit as
          // intended.  Return an internal error instead.  (Would be nicer to
          // abort in principle, but it wouldn't be a nice experience if it ever
@@@ -339,6 -339,6 +339,7 @@@ in
  cli::main(const int argc, const char* const* const argv)
  {
      logging::set_inmemory();
++    signals::setup_interrupts();
  
      LI(F("%s %s") % PACKAGE % VERSION);
  
diff --cc utils/fs/auto_cleaners.cpp
index 94ef944,94ef944..527118b
--- a/utils/fs/auto_cleaners.cpp
+++ b/utils/fs/auto_cleaners.cpp
@@@ -35,10 -35,10 +35,8 @@@
  #include "utils/logging/macros.hpp"
  #include "utils/noncopyable.hpp"
  #include "utils/sanity.hpp"
--#include "utils/signals/interrupts.hpp"
  
  namespace fs = utils::fs;
--namespace signals = utils::signals;
  
  
  /// Shared implementation of the auto_directory.
@@@ -120,7 -120,7 +118,6 @@@ fs::auto_directory::~auto_directory(voi
  fs::auto_directory
  fs::auto_directory::mkdtemp_public(const std::string& path_template)
  {
--    signals::interrupts_inhibiter inhibiter;
      const fs::path directory_ = fs::mkdtemp_public(path_template);
      try {
          return auto_directory(directory_);
@@@ -228,7 -228,7 +225,6 @@@ fs::auto_file::~auto_file(void
  fs::auto_file
  fs::auto_file::mkstemp(const std::string& path_template)
  {
--    signals::interrupts_inhibiter inhibiter;
      const fs::path file_ = fs::mkstemp(path_template);
      try {
          return auto_file(file_);
diff --cc utils/process/child.cpp
index fef09cc,fef09cc..d594430
--- a/utils/process/child.cpp
+++ b/utils/process/child.cpp
@@@ -202,16 -202,16 +202,13 @@@ process::child::fork_capture_aux(void
      if (detail::syscall_pipe(fds) == -1)
          throw process::system_error("pipe(2) failed", errno);
  
--    std::auto_ptr< signals::interrupts_inhibiter > inhibiter(
--        new signals::interrupts_inhibiter);
      pid_t pid = detail::syscall_fork();
      if (pid == -1) {
--        inhibiter.reset(NULL);  // Unblock signals.
          ::close(fds[0]);
          ::close(fds[1]);
          throw process::system_error("fork(2) failed", errno);
      } else if (pid == 0) {
--        inhibiter.reset(NULL);  // Unblock signals.
++        signals::reset_interrupts();
          ::setsid();
  
          try {
@@@ -228,7 -228,7 +225,6 @@@
          ::close(fds[1]);
          LD(F("Spawned process %s: stdout and stderr inherited") % pid);
          signals::add_pid_to_kill(pid);
--        inhibiter.reset(NULL);  // Unblock signals.
          return std::auto_ptr< process::child >(
              new process::child(new impl(pid, new process::ifdstream(fds[0]))));
      }
@@@ -259,14 -259,14 +255,11 @@@ process::child::fork_files_aux(const fs
      std::cout.flush();
      std::cerr.flush();
  
--    std::auto_ptr< signals::interrupts_inhibiter > inhibiter(
--        new signals::interrupts_inhibiter);
      pid_t pid = detail::syscall_fork();
      if (pid == -1) {
--        inhibiter.reset(NULL);  // Unblock signals.
          throw process::system_error("fork(2) failed", errno);
      } else if (pid == 0) {
--        inhibiter.reset(NULL);  // Unblock signals.
++        signals::reset_interrupts();
          ::setsid();
  
          try {
@@@ -289,7 -289,7 +282,6 @@@
          LD(F("Spawned process %s: stdout=%s, stderr=%s") % pid % stdout_file %
             stderr_file);
          signals::add_pid_to_kill(pid);
--        inhibiter.reset(NULL);  // Unblock signals.
          return std::auto_ptr< process::child >(
              new process::child(new impl(pid, NULL)));
      }
diff --cc utils/process/executor.cpp
index dbdf312,dbdf312..1208dad
--- a/utils/process/executor.cpp
+++ b/utils/process/executor.cpp
@@@ -538,9 -538,9 +538,6 @@@ struct utils::process::executor::execut
      /// easy mechanism to discern their unique work directories.
      size_t last_subprocess;
  
--    /// Interrupts handler.
--    std::auto_ptr< signals::interrupts_handler > interrupts_handler;
--
      /// Root work directory for all executed subprocesses.
      std::auto_ptr< fs::auto_directory > root_work_directory;
  
@@@ -555,7 -555,7 +552,6 @@@
      /// Constructor.
      impl(void) :
          last_subprocess(0),
--        interrupts_handler(new signals::interrupts_handler()),
          root_work_directory(new fs::auto_directory(
              fs::auto_directory::mkdtemp_public(work_directory_template))),
          cleaned(false)
@@@ -616,9 -616,9 +612,6 @@@
                 % e.what());
          }
          root_work_directory.reset(NULL);
--
--        interrupts_handler->unprogram();
--        interrupts_handler.reset(NULL);
      }
  
      /// Common code to run after any of the wait calls.
diff --cc utils/process/executor_test.cpp
index de72581,de72581..e03e866
--- a/utils/process/executor_test.cpp
+++ b/utils/process/executor_test.cpp
@@@ -57,6 -57,6 +57,7 @@@ extern "C" 
  #include "utils/process/status.hpp"
  #include "utils/sanity.hpp"
  #include "utils/signals/exceptions.hpp"
++#include "utils/signals/interrupts.hpp"
  #include "utils/stacktrace.hpp"
  #include "utils/text/exceptions.hpp"
  #include "utils/text/operations.ipp"
@@@ -795,6 -795,6 +796,7 @@@ do_signal_handling_test(const int signo
      const pid_t pid = ::fork();
      ATF_REQUIRE(pid != -1);
      if (pid == 0) {
++        signals::reset_interrupts();
          static const std::size_t num_children = 3;
  
          optional< fs::path > root_work_directory;
@@@ -866,6 -866,6 +868,8 @@@
  ATF_TEST_CASE_WITHOUT_HEAD(integration__signal_handling);
  ATF_TEST_CASE_BODY(integration__signal_handling)
  {
++    signals::setup_interrupts();
++
      // This test scenario is racy so run it multiple times to have higher
      // chances of exposing problems.
      const std::size_t rounds = 20;
diff --cc utils/process/operations.cpp
index abcc49f,abcc49f..b4cca70
--- a/utils/process/operations.cpp
+++ b/utils/process/operations.cpp
@@@ -248,10 -248,10 +248,7 @@@ process::statu
  process::wait(const int pid)
  {
      const process::status status = safe_waitpid(pid);
--    {
--        signals::interrupts_inhibiter inhibiter;
--        signals::remove_pid_to_kill(pid);
--    }
++    signals::remove_pid_to_kill(pid);
      return status;
  }
  
@@@ -265,9 -265,9 +262,6 @@@ process::statu
  process::wait_any(void)
  {
      const process::status status = safe_wait();
--    {
--        signals::interrupts_inhibiter inhibiter;
--        signals::remove_pid_to_kill(status.dead_pid());
--    }
++    signals::remove_pid_to_kill(status.dead_pid());
      return status;
  }
diff --cc utils/signals/Kyuafile
index 09da3e1,09da3e1..38b6235
--- a/utils/signals/Kyuafile
+++ b/utils/signals/Kyuafile
@@@ -3,7 -3,7 +3,7 @@@ syntax(2
  test_suite("kyua")
  
  atf_test_program{name="exceptions_test"}
--atf_test_program{name="interrupts_test"}
++--atf_test_program{name="interrupts_test"}
  atf_test_program{name="misc_test"}
  atf_test_program{name="programmer_test"}
  atf_test_program{name="timer_test"}
diff --cc utils/signals/Makefile.am.inc
index b01089c,b01089c..ebd052d
--- a/utils/signals/Makefile.am.inc
+++ b/utils/signals/Makefile.am.inc
@@@ -51,10 -51,10 +51,10 @@@ utils_signals_exceptions_test_SOURCES 
  utils_signals_exceptions_test_CXXFLAGS = $(UTILS_CFLAGS) $(ATF_CXX_CFLAGS)
  utils_signals_exceptions_test_LDADD = $(UTILS_LIBS) $(ATF_CXX_LIBS)
  
--tests_utils_signals_PROGRAMS += utils/signals/interrupts_test
--utils_signals_interrupts_test_SOURCES = utils/signals/interrupts_test.cpp
--utils_signals_interrupts_test_CXXFLAGS = $(UTILS_CFLAGS) $(ATF_CXX_CFLAGS)
--utils_signals_interrupts_test_LDADD = $(UTILS_LIBS) $(ATF_CXX_LIBS)
++#tests_utils_signals_PROGRAMS += utils/signals/interrupts_test
++#utils_signals_interrupts_test_SOURCES = utils/signals/interrupts_test.cpp
++#utils_signals_interrupts_test_CXXFLAGS = $(UTILS_CFLAGS) $(ATF_CXX_CFLAGS)
++#utils_signals_interrupts_test_LDADD = $(UTILS_LIBS) $(ATF_CXX_LIBS)
  
  tests_utils_signals_PROGRAMS += utils/signals/misc_test
  utils_signals_misc_test_SOURCES = utils/signals/misc_test.cpp
diff --cc utils/signals/interrupts.cpp
index 3d45adf,3d45adf..f821d8e
--- a/utils/signals/interrupts.cpp
+++ b/utils/signals/interrupts.cpp
@@@ -35,11 -35,11 +35,16 @@@ extern "C" 
  #include <unistd.h>
  }
  
++#include <atomic>
++#include <condition_variable>
  #include <cstdlib>
--#include <cstring>
++#include <iostream>
++#include <mutex>
  #include <set>
++#include <thread>
  
  #include "utils/logging/macros.hpp"
++#include "utils/noncopyable.hpp"
  #include "utils/process/operations.hpp"
  #include "utils/sanity.hpp"
  #include "utils/signals/exceptions.hpp"
@@@ -53,207 -53,207 +58,136 @@@ namespace 
  
  
  /// The interrupt signal that fired, or -1 if none.
--static volatile int fired_signal = -1;
++static volatile std::atomic_int fired_signal(-1);
++static volatile std::atomic_int fired_signal_count(0);
  
  
  /// Collection of PIDs.
  typedef std::set< pid_t > pids_set;
  
  
--/// List of processes to kill upon reception of a signal.
--static pids_set pids_to_kill;
--
--
--/// Programmer status for the SIGHUP signal.
--static std::auto_ptr< signals::programmer > sighup_handler;
--/// Programmer status for the SIGINT signal.
--static std::auto_ptr< signals::programmer > sigint_handler;
--/// Programmer status for the SIGTERM signal.
--static std::auto_ptr< signals::programmer > sigterm_handler;
--
++static std::mutex pids_to_kill_mutex;
  
--/// Signal mask to restore after exiting a signal inhibited section.
--static sigset_t global_old_sigmask;
  
--
--/// Whether there is an interrupts_handler object in existence or not.
--static bool interrupts_handler_active = false;
++/// List of processes to kill upon reception of a signal.
++static pids_set pids_to_kill;
  
  
--/// Whether there is an interrupts_inhibiter object in existence or not.
--static std::size_t interrupts_inhibiter_active = 0;
++static bool killed = false;
++static std::condition_variable killed_cv;
  
  
  /// Generic handler to capture interrupt signals.
  ///
--/// From this handler, we record that an interrupt has happened so that
--/// check_interrupt() can know whether there execution has to be stopped or not.
--/// We also terminate any of our child processes (started by the
--/// utils::process::children class) so that any ongoing wait(2) system calls
--/// terminate.
--///
  /// \param signo The signal that caused this handler to be called.
  static void
  signal_handler(const int signo)
  {
--    static const char* message = "[-- Signal caught; please wait for "
--        "cleanup --]\n";
--    if (::write(STDERR_FILENO, message, std::strlen(message)) == -1) {
--        // We are exiting: the message printed here is only for informational
--        // purposes.  If we fail to print it (which probably means something
--        // is really bad), there is not much we can do within the signal
--        // handler, so just ignore this.
--    }
--
++    PRE(signo != -1);
++    fired_signal_count++;
      fired_signal = signo;
--
--    for (pids_set::const_iterator iter = pids_to_kill.begin();
--        iter != pids_to_kill.end(); ++iter) {
--        process::terminate_group(*iter);
--    }
  }
  
  
--/// Installs signal handlers for potential interrupts.
++/// Thread to handle interrupts.
  ///
--/// \pre Must not have been called before.
--/// \post The various sig*_handler global variables are atomically updated.
++/// When we receive an interrupt signal, we have to terminate any child
++/// processes that we have spawned so that any other threads blocked on waiting
++/// for them can complete.
  static void
--setup_handlers(void)
++signals_handling_thread(void)
  {
--    PRE(sighup_handler.get() == NULL);
--    PRE(sigint_handler.get() == NULL);
--    PRE(sigterm_handler.get() == NULL);
--
--    // Create the handlers on the stack first so that, if any of them fails, the
--    // stack unwinding cleans things up.
--    std::auto_ptr< signals::programmer > tmp_sighup_handler(
--        new signals::programmer(SIGHUP, signal_handler));
--    std::auto_ptr< signals::programmer > tmp_sigint_handler(
--        new signals::programmer(SIGINT, signal_handler));
--    std::auto_ptr< signals::programmer > tmp_sigterm_handler(
--        new signals::programmer(SIGTERM, signal_handler));
--
--    // Now, update the global pointers, which is an operation that cannot fail.
--    sighup_handler = tmp_sighup_handler;
--    sigint_handler = tmp_sigint_handler;
--    sigterm_handler = tmp_sigterm_handler;
--}
--
--
--/// Uninstalls the signal handlers installed by setup_handlers().
--static void
--cleanup_handlers(void)
--{
--    sighup_handler->unprogram(); sighup_handler.reset(NULL);
--    sigint_handler->unprogram(); sigint_handler.reset(NULL);
--    sigterm_handler->unprogram(); sigterm_handler.reset(NULL);
--}
++    signals::programmer sighup_handler(SIGHUP, signal_handler);
++    signals::programmer sigint_handler(SIGINT, signal_handler);
++    signals::programmer sigterm_handler(SIGTERM, signal_handler);
  
--
--
--/// Masks the signals installed by setup_handlers().
--static void
--mask_signals(sigset_t* old_sigmask)
--{
      sigset_t mask;
      sigemptyset(&mask);
      sigaddset(&mask, SIGALRM);
--    sigaddset(&mask, SIGHUP);
--    sigaddset(&mask, SIGINT);
--    sigaddset(&mask, SIGTERM);
--    const int ret = ::sigprocmask(SIG_BLOCK, &mask, old_sigmask);
--    INV(ret != -1);
--}
  
++    while (fired_signal == -1) {
++        ::sigsuspend(&mask);
++    }
++    std::cerr << "[-- Signal caught; please wait for cleanup --]\n";
++    {
++        std::lock_guard< std::mutex > lock(pids_to_kill_mutex);
++        for (pids_set::const_iterator iter = pids_to_kill.begin();
++             iter != pids_to_kill.end(); ++iter) {
++            process::terminate_group(*iter);
++        }
++        killed = true;
++        killed_cv.notify_one();
++    }
  
--/// Resets the signal masking put in place by mask_signals().
--static void
--unmask_signals(sigset_t* old_sigmask)
--{
--    const int ret = ::sigprocmask(SIG_SETMASK, old_sigmask, NULL);
--    INV(ret != -1);
++    while (fired_signal_count < 2) {
++        ::sigsuspend(&mask);
++    }
++    std::cerr << "[-- Double signal caught; killing self --]\n";
++    ::kill(0, SIGKILL);
  }
  
  
  }  // anonymous namespace
  
  
--/// Constructor that sets up the signal handlers.
--signals::interrupts_handler::interrupts_handler(void) :
--    _programmed(false)
--{
--    PRE(!interrupts_handler_active);
--    setup_handlers();
--    _programmed = true;
--    interrupts_handler_active = true;
--}
++struct utils::signals::interrupts_handler::impl {
++    pid_t creator_pid;
  
++    std::thread interrupts_thread;
  
--/// Destructor that removes the signal handlers.
--///
--/// Given that this is a destructor and it can't report errors back to the
--/// caller, the caller must attempt to call unprogram() on its own.
--signals::interrupts_handler::~interrupts_handler(void)
--{
--    if (_programmed) {
--        LW("Destroying still-programmed signals::interrupts_handler object");
--        try {
--            unprogram();
--        } catch (const error& e) {
--            UNREACHABLE;
--        }
++    /// Signal mask to restore after exiting a signal inhibited section.
++    sigset_t old_sigmask;
++
++    interrupts_handler(void) :
++        creator_pid(::getpid())
++    {
++        interrupts_thread = std::move(std::thread(signals_handling_thread));
++
++        sigset_t mask;
++        sigfillset(&mask);
++        const int ret = ::sigprocmask(SIG_BLOCK, &mask, &old_sigmask);
++        INV(ret != -1);
      }
--}
  
++    ~interrupts_handler(void)
++    {
++        restore();
++        interrupts_handler.detach();  // TODO(jmmv): Need to join this instead.
++    }
  
--/// Unprograms all signals captured by the interrupts handler.
--///
--/// \throw system_error If the unprogramming of any signal fails.
--void
--signals::interrupts_handler::unprogram(void)
--{
--    PRE(_programmed);
++private:
++    void
++    restore(void)
++    {
++        const int ret = ::sigprocmask(SIG_SETMASK, &old_sigmask, NULL);
++        INV(ret != -1);
++    }
++};
  
--    // Modify the control variables first before unprogramming the handlers.  If
--    // we fail to do the latter, we do not want to try again because we will not
--    // succeed (and we'll cause a crash due to failed preconditions).
--    _programmed = false;
--    interrupts_handler_active = false;
  
--    cleanup_handlers();
--    fired_signal = -1;
++signals::interrupts_handler::interrupts_handler(void) :
++    _pimpl(new impl())
++{
  }
  
  
--/// Constructor that sets up signal masking.
--signals::interrupts_inhibiter::interrupts_inhibiter(void)
++signals::interrupts_handler::~interrupts_handler(void)
  {
--    sigset_t old_sigmask;
--    mask_signals(&old_sigmask);
--    if (interrupts_inhibiter_active == 0) {
--        global_old_sigmask = old_sigmask;
--    }
--    ++interrupts_inhibiter_active;
  }
  
  
--/// Destructor that removes signal masking.
--signals::interrupts_inhibiter::~interrupts_inhibiter(void)
++void
++signals::interrupts_handler::reset_for_child_process(void)
  {
--    if (interrupts_inhibiter_active > 1) {
--        --interrupts_inhibiter_active;
--    } else {
--        interrupts_inhibiter_active = false;
--        unmask_signals(&global_old_sigmask);
--    }
++    PRE(::getpid() != _pimpl->creator_pid);
++    _pimpl->restore();
  }
  
  
  /// Checks if an interrupt has fired.
  ///
  /// Calls to this function should be sprinkled in strategic places through the
--/// code protected by an interrupts_handler object.
++/// code.
  ///
  /// Only one call to this function will raise an exception per signal received.
  /// This is to allow executing cleanup actions without reraising interrupt
@@@ -263,8 -263,8 +197,11 @@@
  void
  signals::check_interrupt(void)
  {
--    if (fired_signal != -1) {
--        const int original_fired_signal = fired_signal;
++    const int original_fired_signal = fired_signal;
++    if (original_fired_signal != -1) {
++        std::unique_lock< std::mutex > lock(pids_to_kill_mutex);
++        killed_cv.wait(lock, []{return killed;});
++
          fired_signal = -1;
          throw interrupted_error(original_fired_signal);
      }
@@@ -280,7 -280,7 +217,7 @@@
  void
  signals::add_pid_to_kill(const pid_t pid)
  {
--    PRE(interrupts_inhibiter_active);
++    std::lock_guard< std::mutex > guard(pids_to_kill_mutex);
      PRE(pids_to_kill.find(pid) == pids_to_kill.end());
      pids_to_kill.insert(pid);
  }
@@@ -297,7 -297,7 +234,37 @@@
  void
  signals::remove_pid_to_kill(const pid_t pid)
  {
--    PRE(interrupts_inhibiter_active);
++    std::lock_guard< std::mutex > guard(pids_to_kill_mutex);
      PRE(pids_to_kill.find(pid) != pids_to_kill.end());
      pids_to_kill.erase(pid);
  }
++
++
++void
++signals::setup_interrupts(void)
++{
++    std::thread thread(signals_handling_thread);
++    thread.detach();
++
++    sigset_t mask;
++    sigfillset(&mask);
++    const int ret = ::sigprocmask(SIG_BLOCK, &mask, &old_sigmask);
++    INV(ret != -1);
++}
++
++
++void
++signals::reset_interrupts_for_child(void)
++{
++    const int ret = ::sigprocmask(SIG_SETMASK, &old_sigmask, NULL);
++    INV(ret != -1);
++}
++
++
++void
++signals::redeliver_to_exit(const int signo)
++{
++    fired_signal_count = 0;
++    ::kill(::getpid(), signo);
++    LD("Interrupt signal re-delivery did not terminate program");
++}
diff --cc utils/signals/interrupts.hpp
index b181114,b181114..fd7eddb
--- a/utils/signals/interrupts.hpp
+++ b/utils/signals/interrupts.hpp
@@@ -36,38 -36,38 +36,19 @@@
  
  #include <unistd.h>
  
--#include "utils/noncopyable.hpp"
--
  namespace utils {
  namespace signals {
  
  
--/// Provides a scope in which interrupts can be detected and handled.
--///
--/// This RAII-modeled object installs signal handler when instantiated and
--/// removes them upon destruction.  While this object is active, the
--/// check_interrupt() free function can be used to determine if an interrupt has
--/// happened.
--class interrupts_handler : noncopyable {
--    /// Whether the interrupts are still programmed or not.
--    ///
--    /// Used by the destructor to prevent double-unprogramming when unprogram()
--    /// is explicitly called by the user.
--    bool _programmed;
++class interrupts_handler {
++    struct impl;
++    std::unique_ptr< impl > _pimpl;
  
  public:
--    interrupts_handler(void);
--    ~interrupts_handler(void);
++    interrupts_handler();
++    ~interrupts_handler();
  
--    void unprogram(void);
--};
--
--
--/// Disables interrupts while the object is alive.
--class interrupts_inhibiter : noncopyable {
--public:
--    interrupts_inhibiter(void);
--    ~interrupts_inhibiter(void);
++    void reset_for_child_process(void);
  };
  
  
@@@ -76,6 -76,6 +57,11 @@@ void check_interrupt(void)
  void add_pid_to_kill(const pid_t);
  void remove_pid_to_kill(const pid_t);
  
++void setup_interrupts(void);
++void reset_interrupts(void);
++
++void redeliver_to_exit(const int);
++
  
  } // namespace signals
  } // namespace utils
diff --cc utils/signals/timer.cpp
index 7811a61,7811a61..2468555
--- a/utils/signals/timer.cpp
+++ b/utils/signals/timer.cpp
@@@ -46,7 -46,7 +46,6 @@@ extern "C" 
  #include "utils/optional.ipp"
  #include "utils/sanity.hpp"
  #include "utils/signals/exceptions.hpp"
--#include "utils/signals/interrupts.hpp"
  #include "utils/signals/programmer.hpp"
  
  namespace datetime = utils::datetime;
@@@ -152,8 -152,8 +151,6 @@@ class global_state : utils::noncopyabl
      /// Calculates all timers to execute at this timestamp.
      ///
      /// \param now The current timestamp.
--    /// \param unused_inhibiter Reference to the active interrupts inhibiter, to
--    ///     ensure that this is called with interrupts inhibited.
      ///
      /// \post _all_timers is updated to contain only the timers that are
      /// strictly in the future.
@@@ -162,9 -162,9 +159,7 @@@
      /// of activation.  These are all previously registered timers with
      /// activations in the past.
      timers_vector
--    compute_timers_to_run_and_prune_old(
--        const datetime::timestamp& now,
--        const signals::interrupts_inhibiter& UTILS_UNUSED_PARAM(inhibiter))
++    compute_timers_to_run_and_prune_old(const datetime::timestamp& now)
      {
          timers_vector to_run;
  
@@@ -187,14 -187,14 +182,10 @@@
      /// Adjusts the global system timer to point to the next activation.
      ///
      /// \param now The current timestamp.
--    /// \param unused_inhibiter Reference to the active interrupts inhibiter, to
--    ///     ensure that this is called with interrupts inhibited.
      ///
      /// \throw system_error If the programming fails.
      void
--    reprogram_system_timer(
--        const datetime::timestamp& now,
--        const signals::interrupts_inhibiter& UTILS_UNUSED_PARAM(inhibiter))
++    reprogram_system_timer(const datetime::timestamp& now)
      {
          if (_all_timers.empty()) {
              // Nothing to do.  We can reach this case if all the existing timers
@@@ -248,8 -248,8 +239,6 @@@ public
      {
          PRE(now < timer->when());
  
--        signals::interrupts_inhibiter inhibiter;
--
          const datetime::delta delta = timer->when() - now;
          LD(F("Installing first timer; firing on %s; now is %s") %
             timer->when() % now);
@@@ -271,8 -271,8 +260,6 @@@
      /// This clears the global system timer and unsets the SIGALRM handler.
      ~global_state(void)
      {
--        signals::interrupts_inhibiter inhibiter;
--
          LD("Unprogramming all timers");
  
          if (::setitimer(ITIMER_REAL, &_old_timeval, NULL) == -1) {
@@@ -296,10 -296,10 +283,8 @@@
      void
      program_new(signals::timer* timer, const datetime::timestamp& now)
      {
--        signals::interrupts_inhibiter inhibiter;
--
          add_to_all_timers(timer);
--        reprogram_system_timer(now, inhibiter);
++        reprogram_system_timer(now);
      }
  
      /// Unprograms a timer.
@@@ -314,15 -314,15 +299,13 @@@
      bool
      unprogram(signals::timer* timer)
      {
--        signals::interrupts_inhibiter inhibiter;
--
          LD(F("Unprogramming timer; previously firing on %s") % timer->when());
  
          remove_from_all_timers(timer);
          if (_all_timers.empty()) {
              return false;
          } else {
--            reprogram_system_timer(datetime::timestamp::now(), inhibiter);
++            reprogram_system_timer(datetime::timestamp::now());
              return true;
          }
      }
@@@ -337,9 -337,9 +320,8 @@@
      {
          timers_vector to_run;
          {
--            signals::interrupts_inhibiter inhibiter;
--            to_run = compute_timers_to_run_and_prune_old(now, inhibiter);
--            reprogram_system_timer(now, inhibiter);
++            to_run = compute_timers_to_run_and_prune_old(now);
++            reprogram_system_timer(now);
          }
  
          for (timers_vector::iterator iter = to_run.begin();
@@@ -424,8 -424,8 +406,6 @@@ struct utils::signals::timer::impl : ut
  /// \param delta The time until the timer fires.
  signals::timer::timer(const datetime::delta& delta)
  {
--    signals::interrupts_inhibiter inhibiter;
--
      const datetime::timestamp now = datetime::timestamp::now();
      _pimpl.reset(new impl(now + delta));
      if (globals.get() == NULL) {
@@@ -443,8 -443,8 +423,6 @@@
  /// extremely important because, otherwise, expired timers will never run!
  signals::timer::~timer(void)
  {
--    signals::interrupts_inhibiter inhibiter;
--
      if (_pimpl->programmed) {
          LW("Auto-destroying still-programmed signals::timer object");
          try {
@@@ -522,8 -522,8 +500,6 @@@ signals::timer::fired(void) cons
  void
  signals::timer::unprogram(void)
  {
--    signals::interrupts_inhibiter inhibiter;
--
      if (!_pimpl->programmed) {
          // We cannot assert that the timer is not programmed because it might
          // have been unprogrammed asynchronously between the time we called
diff --cc utils/signals/timer_test.cpp
index 3711048,3711048..28de999
--- a/utils/signals/timer_test.cpp
+++ b/utils/signals/timer_test.cpp
@@@ -53,6 -53,6 +53,25 @@@ namespace signals = utils::signals
  namespace {
  
  
++class sigalrm_inhibiter {
++    sigset_t _old_mask;
++
++public:
++    sigalrm_inhibiter(void)
++    {
++        sigset_t mask;
++        sigemptyset(&mask);
++        sigaddset(&mask, SIGALRM);
++        ATF_REQUIRE(::sigprocmask(SIG_BLOCK, &mask, &_old_mask) != -1);
++    }
++
++    ~sigalrm_inhibiter(void)
++    {
++        ATF_REQUIRE(::sigprocmask(SIG_SETMASK, &_old_mask, NULL) != -1);
++    }
++};
++
++
  /// A timer that inserts an element into a vector on activation.
  class delayed_inserter : public signals::timer {
      /// Vector into which to insert the element.
@@@ -65,7 -65,7 +84,7 @@@
      void
      callback(void)
      {
--        signals::interrupts_inhibiter inhibiter;
++        sigalrm_inhibiter inhibiter;
          _destination.push_back(_item);
      }
  
@@@ -268,7 -268,7 +287,7 @@@ ATF_TEST_CASE_BODY(multiprogram_and_exp
      std::vector< int > items;
  
      {
--        signals::interrupts_inhibiter inhibiter;
++        sigalrm_inhibiter inhibiter;
  
          // First timer with an activation in the future.
          timers.push_back(new delayed_inserter(
@@@ -313,7 -313,7 +332,7 @@@ ATF_TEST_CASE_BODY(expire_before_firing
      signals::programmer sigalrm(SIGALRM, null_handler);
  
      {
--        signals::interrupts_inhibiter inhibiter;
++        sigalrm_inhibiter inhibiter;
  
          delayed_inserter* timer = new delayed_inserter(
              datetime::delta(0, 1000), items, 1234);
